#define RANGE Range(1000000LL, 1000000LL)
#define MULT RangeMultiplier(2)

static void BM_Range_stride_skip_half(benchmark::State& state) {
  for (auto _ : state) {
    long long sum = 0;
    auto range_gen = gen::range(state.range(0));
    auto sum_range = pipe::stride(2) >>= sink::sum(sum);
    range_gen >>= sum_range;
    printf("%lld\n", sum);
    assert(sum == 249999999500000000);
  }
}
BENCHMARK(BM_Range_stride_skip_half)->Range(1000000000LL, 1000000000LL);  //->MULT->RANGE;

static void BM_Range_partition_skip_half(benchmark::State& state) {
  for (auto _ : state) {
    long long sum = 0;
    auto range_gen = gen::range(state.range(0));
    auto sum_range = pipe::partition([](auto i) { return ((i & 1) == 0); },
                                     sink::sum(sum), sink::hole());
    range_gen >>= sum_range;
    assert(sum == 249999999500000000);
  }
}
BENCHMARK(BM_Range_partition_skip_half)
    ->Range(1000000000LL, 1000000000LL);  //->MULT->RANGE;

static void BM_Range_arithmetic_skip_half(benchmark::State& state) {
  for (auto _ : state) {
    long long sum = 0;
    auto range_gen = gen::range(state.range(0));
    auto sum_range 
    =   pipe::transform([](auto i){ return i * ((i&1)==0); })
    >>= sink::sum(sum);
    range_gen >>= sum_range;
    assert(sum == 249999999500000000);
  }
}
BENCHMARK(BM_Range_arithmetic_skip_half)
    ->Range(1000000000LL, 1000000000LL);  //->MULT->RANGE;

static void BM_ForLoop_stride_skip_half(benchmark::State& state) {
  for (auto _ : state) {
    long long sum = 0;
    int stride = 0;
    for (long long i = 0; i < state.range(0); ++i) {
      if (stride == 0) {
        sum += i;
        stride = 1;
      } else {
        --stride;
      }
    }
    assert(sum == 249999999500000000);
  }
}
BENCHMARK(BM_ForLoop_stride_skip_half)
    ->Range(1000000000LL, 1000000000LL);  //->MULT->RANGE;

static void BM_ForLoop_bool_skip_half(benchmark::State& state) {
  for (auto _ : state) {
    long long sum = 0;
    bool skip = false;
    for (long long i = 0; i < state.range(0); ++i) {
      if (skip) {
        skip = false;
      } else {
        sum += i;
        skip = true;
      }
    }
    assert(sum == 249999999500000000);
  }
}
BENCHMARK(BM_ForLoop_bool_skip_half)->Range(1000000000LL, 1000000000LL);  //->MULT->RANGE;

static void BM_ForLoop_bool_artihmetic_skip_half(benchmark::State& state) {
  for (auto _ : state) {
    long long sum = 0;
    bool keep = true;
    for (long long i = 0; i < state.range(0); ++i) {
      sum += (i * keep);
      keep = !keep;
    }
    assert(sum == 249999999500000000);
  }
}
BENCHMARK(BM_ForLoop_bool_artihmetic_skip_half)->Range(1000000000LL, 1000000000LL);  //->MULT->RANGE;

BENCHMARK_MAIN();
